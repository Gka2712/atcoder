/*
問題文
縦 N マス、横 N マスのグリッドが 2 個与えられます。それぞれグリッド A, グリッド B と呼びます。
グリッドの各マスには英小文字が書かれています。
グリッド A の上から i 行目、左から j 列目に書かれている文字は A i,jです。
グリッド 
B の上から i 行目、左から j 列目に書かれている文字は B i,jです。
2 つのグリッドは 1 ヵ所だけ書かれている文字が異なります。すなわち、A i,j=B i,j でないN 以下の正整数の組 (i,j) ちょうど 1 個存在します。この (i,j) を求めてください。
制約
1≤N≤100
A i,j,B i,jは全て英小文字
A i,j￢＝B i,jである 
(i,j) がちょうど 1 個存在する
入力
入力は以下の形式で標準入力から与えられる。
NA 1,1A1,2…A 1,N
A 2,1A 2,2…A 2,N
⋮
A N,1A N,2…A N,N
B 1,1B 1,2 …B 1,N
B 2,1B 2,2…B 2,N
⋮
B N,1B N,2…B N,N
​
 出力
AijがBijではないN以下の正整数の組を(i,j)とする。この時、(i,j)を以下の形式で出力せよ
i  j


*/
#include <stdio.h>

int main() {
    int N;
    scanf("%d", &N);

    char A[N][N+1]; // グリッドAの各行を格納する配列
    char B[N][N+1]; // グリッドBの各行を格納する配列

    // グリッドAを入力
    for (int i = 0; i < N; i++) {
        scanf("%s", A[i]);
    }

    // グリッドBを入力
    for (int i = 0; i < N; i++) {
        scanf("%s", B[i]);
    }

    // AとBを比較し、異なる文字を見つける
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (A[i][j] != B[i][j]) {
                printf("%d %d\n", i+1, j+1); // (i,j)を出力
                return 0; // 異なる文字を見つけたら終了
            }
        }
    }

    return 0;
}
/*
1回目上の問題をChatGPTに解かせ、コードを生成。結果:正解
*/