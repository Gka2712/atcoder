コード生成要件
・このコードをC言語で作ってください。
・問題の内容を以下にまとめます。
縦Nマス、横Nマスのグリッドが2個与えられます。それぞれグリッドA,グリッドBと呼びます。
グリッドの各マスには英小文字が書かれています。
グリッドAの上からi行目、左からj列目に書かれている文字はA(i,j)です。
グリッドBの上からi行目、左からj列目に書かれている文字はB(i,j)です。
二つのグリッドは1か所だけ書かれている文字が異なります。すなわちA(i,j)=B(i,j)ではないN以下の正整数の組(i,j)はちょうど1個存在します。
個の(i,j)を求めてください。
・次に問題の制約を以下にまとめます。
1<=N<=100
A(i,j),B(i,j)は全て英小文字
A(i,j)=B(i,j)ではない(i,j)がちょうど一個存在する
・入力フォーマット
A(1,1) A(1,2) ・・・・・・・・A(1,N)
A(2,1) A(2,2) ・・・・・・・・A(2,N)
・
・
・
・
A(N,1) A(N,2) ・・・・・・・・A(N,N)
B(1,1) B(1,2)　・・・・・・・B(1,N)
B(2,1) B(2,2)　・・・・・・・B(2,N)
・
・
・
・
・
・
B(N,1)B(N,2)・・・・・・・・B(N,N)
・出力フォーマット
A(1,j)=B(i,j)ではないN以下の正整数の組を(i,j)とする。この時(i,j)を以下の形式で出力せよ
i j
では問題をとき、コードを生成してください

#include <stdio.h>

int main() {
    int N;
    scanf("%d", &N);

    char grid_A[N][N];
    char grid_B[N][N];

    // グリッドAの入力
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            scanf(" %c", &grid_A[i][j]); // スペースを入れて、改行を読み飛ばす
        }
    }

    // グリッドBの入力
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            scanf(" %c", &grid_B[i][j]); // スペースを入れて、改行を読み飛ばす
        }
    }

    // 異なる文字の位置を見つける
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if (grid_A[i][j] != grid_B[i][j]) {
                printf("%d %d\n", i + 1, j + 1);
                return 0;
            }
        }
    }

    return 0;
}
