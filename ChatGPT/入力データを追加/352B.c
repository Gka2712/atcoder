コード生成要件
・このコードをC言語で作ってください。
・問題の内容を以下にまとめます。
高橋君は英小文字からなる文字列Sをキーボードで入力しようとしていました。
高橋君は画面を見ずにキーボードだけを見てタイピングをしていました。
誤って別の詠唱文字を入力してしまった時にはその直後にバックスペースキーを押しましたが、バックスペースキーが壊れていたため誤って入力された文字は消去されず、実際に入力された文字列はTとなりました。Tのうち、高橋君が誤って入力した文字でないものを正しく入力された文字であると定めます。
正しく入力された文字がTの何文字目であるか答えてください。
・次に問題の制約を以下にまとめます。
S,Tは長さ1以上2×(10の5乗)以下の英小文字から成る文字列
Tは問題文中の手続きにより得られる文字列
入力フォーマット
入力は以下の形式で標準入力が与えられる。
S
T
一行目で文字列Sを入力、その後文字列Tを入力。
出力フォーマット
Sの長さを|S|として、正しく入力された文字がA1,A2,・・・・・,A|S|文字目である時A1,A2,・・・・A|S|の値をこの順に空白区切りで出力せよ。
ただし各々1<=i<=|S|-1に対してAi<A(i+1)を満たすようにせよ。
処理例
例えば1行目で、「abc」、2行目で、「axbxyc」と入力されたとします。
高橋君のタイピングの一連の流れは以下のようになります。
aを入力する。
bを入力しようとするけれど、誤ってxを入力してしまう。
bを入力する。
cを入力しようとするけれど、誤ってxを入力する。
cを入力する。
このタイピングの一連の流れより、正しく入力された文字は、1、3、6文字なので、「1,3,6」と出力します。
では問題を解き、コードを生成してください。
不正解

#include <stdio.h>
#include <string.h>

int main() {
    char S[200001]; // Sの長さの上限は2*10^5なので十分なサイズの配列を確保する
    char T[200001]; // Tの長さの上限は2*10^5なので十分なサイズの配列を確保する
    scanf("%s", S);
    scanf("%s", T);

    int len_S = strlen(S);
    int len_T = strlen(T);

    int idx_S = 0; // Sの現在の文字位置
    int idx_T = 0; // Tの現在の文字位置

    // 正しく入力された文字の位置を保存する配列
    int correct_positions[200001]; // 上限の長さに合わせて適切なサイズの配列を確保する
    int correct_idx = 0; // 正しく入力された文字の数

    // Tを順に走査して、Sと一致する文字を見つける
    while (idx_T < len_T) {
        // Tの現在の文字とSの現在の文字が一致した場合、Sの次の文字へ移動
        if (T[idx_T] == S[idx_S]) {
            correct_positions[correct_idx++] = idx_S + 1; // 1-indexedにするため+1する
            idx_S++;
        }
        idx_T++;
    }

    // 正しく入力された文字の位置を出力
    for (int i = 0; i < correct_idx; i++) {
        printf("%d", correct_positions[i]);
        if (i < correct_idx - 1) {
            printf(" ");
        }
    }
    printf("\n");

    return 0;
}
/*
#include <stdio.h>
#include <string.h>

int main() {
    char S[200001]; // Sの長さの上限は2*10^5なので十分なサイズの配列を確保する
    char T[200001]; // Tの長さの上限は2*10^5なので十分なサイズの配列を確保する
    scanf("%s", S);
    scanf("%s", T);

    int len_S = strlen(S);
    int len_T = strlen(T);

    int idx_S = 0; // Sの現在の文字位置
    int idx_T = 0; // Tの現在の文字位置

    // 正しく入力された文字の位置を保存する配列
    int correct_positions[200001]; // 上限の長さに合わせて適切なサイズの配列を確保する
    int correct_idx = 0; // 正しく入力された文字の数

    // Tを順に走査して、Sと一致する文字を見つける
    while (idx_T < len_T) {
        // Tの現在の文字とSの現在の文字が一致した場合、Sの次の文字へ移動
        if (T[idx_T] == S[idx_S]) {
            correct_positions[correct_idx++] = idx_T + 1; // 1-indexedにするため+1する
            idx_S++;
        }
        idx_T++;
    }

    // 正しく入力された文字の位置を出力
    for (int i = 0; i < correct_idx; i++) {
        printf("%d", correct_positions[i]);
        if (i < correct_idx - 1) {
            printf(" ");
        }
    }
    printf("\n");

    return 0;
}
原因
処理ミス
文字が一致しているTの位置を答える所が、文字が一致しているSの位置を答えてしまっている。
*/